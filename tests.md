# Задание 1
Дана строка s, содержащая только символы ```'('```, ```')'```, ```'{'```, ```'}'```, ```'['``` и ```']'```, определите является входная строка допустимой. 

Строка является допустимой если:
1. Открытые скобки должны закрываться тем же видом скобок
2. Открытые скобки должны закрываться в правильном порядке
3. Каждая закрывающая скобка имеет соответствующую открывающую скобку того же типа

### Пример 1:
```
Input: s = "()"

Output: true
```
### Пример 2:
```
Input: s = "()[]{}"

Output: true
```
### Пример 3:
```
Input: s = "(]"

Output: false
```
### Пример 4:
```
Input: s = "([])"

Output: true
```
### Пример 5:
```
Input: s = "([)]"

Output: false
```
### Ограничения:
* ```1 <= s.length <= 10^4```
* ```s состоит только из скобок '(){}[]'.```



# Задание 2
Даны два целочисленных массива ```nums1``` и ```nums2```, отсортированных в **неубывающем порядке**, и два целых числа ```m``` и ```n```, представляющих количество элементов массивов ```nums1``` и ```nums2``` соответственно.

**Объедините** ```nums1``` и ```nums2``` в один целочисленный массив, отсортированный в **неубывающем порядке**.

Итоговый отсортированный массив должен не возвращаться из функции, а *храниться в массиве* ```nums1```. Для достижения этого, ```nums1``` имеет длину ```m+n```, где первые ```m``` элементов обозначают элементы, которые должны быть объединен, и оставшиеся ```n``` элементов установлены в ```0``` и должны игнорироваться. ```nums2``` имеет длину ```n```.

### Пример 1:
```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Пояснение: Объединяемые массивы это [1,2,3] и [2,5,6].
Результат объединения это [1,2,2,3,5,6].
```
### Пример 2:
```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Пояснение: Объединяемые массивы это [1] и [].
Результат объединения это [1].
```
### Пример 3:
```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Пояснение: Объединяемые массивы это [] и [1].
Результат объединения это [1].
Заметим что т.к. m = 0, в массиве nums1 нет элементов для объединения. 0 нужен только для того, чтобы в nums1 было место для записи результирующего массива.
```

### Ограничения:
* ```nums1.length == m + n```
* ```nums2.length == n```
* ``` 0 <= m, n <= 200```
* ```1 <= m + n <= 200```
* ```-10^9 <= nums1[i], nums2[j] <= 10^9```




# Задание 3
Дан целочисленный массив ```prices``` где ```prices[i]``` это цена некоторой акции на i-й день.

Вам нужно максимизировать прибыль, выбрав **один день** чтобы купить акции и **другой день в будущем** чтобы продать акции.

Верните *максимальную возможную прибыль от транзакции*. Если невозможно получить прибыль, верните ```0```.

### Пример 1:
```
Input: prices = [7,1,5,3,6,4]
Output: 5
Пояснение: Купить на день 2 (price = 1) и продать на день 5 (price = 6), прибыль = 6-1 = 5.
Заметим, что купить на день 2 и продать на день 1 нельзя, поскольку вы должны купить акции, прежде чем их продавать.
```
### Пример 2:
```
Input: prices = [7,6,4,3,1]
Output: 0
Пояснение: В данном случае невозможно совершить прибыльных транзакций, поэтому максимальная прибыль = 0.
```
### Ограничения:
* ```1 <= prices.length <= 10^5```
* ```0 <= prices[i] <= 10^4```




# Задание 4
Дано две строки ```s``` и ```t```, вернуть ```true``` если ```t``` является анаграммой ```s```, и ```false``` в противном случае.

### Пример 1:
```
Input: s = "anagram", t = "nagaram"

Output: true
```
### Пример 2:
```
Input: s = "rat", t = "car"

Output: false
```
### Ограничения:
* ```1 <= s.length, t.length <= 5 * 10^4```
* ```s и t состоят из строчных латинских букв```




# Задание 5
Есть класс ```RecentCounter```, который считает количество недавних запросов в течение конкретного промежутка времени.

Реализуйте класс ```RecentCounter```:
* ```RecentCounter()``` Инициализирует счетчик с 0 недавних запросов.
* ```int ping(int t)``` Добавляет новый запрос в момент времени ```t```, где ```t``` представляет некоторое время в миллисекундах, и возвращает количество запросов, которые случились в предыдущие ```3000``` миллисекунд (включая новый запрос). Конкретно, верните количество запросов, которые случились в диапазоне ```[t-3000, t]```.

**Гарантируется**, что каждый вызов ```ping``` использует исключительно большее значение ```t```, чем предыдущий вызов.

### Пример 1:
```
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1
recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2
recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3
```
### Ограничения:
* ```1 <= t <= 10^9```
* ```Каждый тестовый случай вызывает ping со строго увеличивающимися значениями t```
* ```Метод ping будет вызван максимум 10^4 раз.```